;; TODO implement direct sin, cos, and tan instruction mappings
;; TODO reimplement the test operations since it makes for more compact code
;; clzsi2 (count leading zeros)
;;  scanbit src, dest // find the most significant 1 bit
;;  subo 31, dest, dest2 // subtract 31 from it to get the index
;; extzvsi ... Extract bit field and zero extend 
;;  extract
;; insvsi ...
;;  modify
;; extv ... Extract bit field but from register or memory operand
;; insv
;; TODO support the compare and test operations separately since it is more
;; efficent than using cbranchsi based design. Gcc 3.4.6 actually supports
;; emitting the separate compare and test instructions. I want to emulate this
;; since we support this easily. A good way to know this is basically this:
;; 
;; mov 1, c
;; compare a, b
;; branch? skip
;; mov 0, c
;; skip:
;;
;; condition code is a special register which translate to:
;;
;; compare a, b
;; test? c
;;
;; 

;; the compaction of load and store instructions to save operations needs to
;; happen next I am seeing

;; instructions that are not used by the compiler but could come in handy some day
;;
;; This is not all of the unused instructions, just stuff that could be useful
;;
;; addc
;; alterbit
;; atadd
;; atmod
;; standalone branch instructions?? (questionable)
;; chkbit
;; cmpdeci
;; cmpdeco
;; cmpinci
;; cmpinco
;; cmpor (numerics)
;; cmporl (numerics)
;; cmpstr (protected)
;; concmpi (useful for generating twixt sequences)
;; concmpo (useful for generating twixt sequences)
;; ediv (long ordinal in src2 only but emits remainder and quotient in two registers!)
;; extract
;; fill (protected)
;; modac (if we need to extract the condition code explicitly)
;; modi (not C standard compliant)
;; modify
;; movqstr (protected)
;; movstr (protected)
;; rotate
;; scanbit (search for the most significant set bit and also modifies cc) 
;; scanbyte (byte-by-byte comparison of src1 and src2 and sets cc to true if
;;           any two corresponding bytes are equal)
;; spanbit (search for the most significant clear bit and also modifies cc) 


;; I am thinking that we can use scanbit, scanbyte, and spanbit to support
;; various optimizations. 
;;
;; For example, 
;;    we can implement count leading zeros using spanbit
;;    we can implement count leading ones using scanbit
;;
;; We can use scanbyte to quickly test during a string compare that is
;; optimized to do 32-bit checks. It allows us to blindly load 32-bit values
;; and check to see if we should even check byte by byte. It really is meant
;; for high speed compare operations since we can load packed data without
;; worry. This would be more of a fail test than anything else.

;; Mysteries to diagnose:
;; 1) why is g14 being used in place of fp when va_args are in use? This is _WRONG_
;; 1a) It has nothing to do with setting up for incoming varargs!
;; 1b) It also has nothing to do with va_start
;; 1c) There is some sort of dumb equivalence being stated somewhere

;; I figured out how to implement floatdidf2 earlier today but ran into issues
;; with match problems. Github Copilot helped me realize I need to use a
;; match_scratch operand in the define_insn for the intermediary.
;;
;; According to the intel manual, it is a two instruction sequence to do di to
;; df conversion. You use cvtilr and then a movl to the destination
;; todo What about just the cvtilr due to using the floating point register?
;; todo what about movrl 0.0f,%0
;; todo what about movrl 1.0f,%0
