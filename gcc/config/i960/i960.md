;;- Machine description for Intel 80960 chip for GNU C compiler
;;   Copyright (C) 1992, 1995, 1998, 2001 Free Software Foundation, Inc.
;;   Contributed by Steven McGeady, Intel Corp.
;;   Additional work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson
;;   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.
;;   Updated to gcc 11.3.0 by Joshua Scoggins

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
(include "constraints.md")
(include "predicates.md")

;; There are very few (4) 'f' registers, they can't be loaded/stored from/to
;; memory, and some instructions explicitly require them, so we get better
;; code by discouraging pseudo-registers from being allocated to them.
;; However, we do want to allow all patterns which can store to them to
;; include them in their constraints, so we always use '*f' in a destination
;; constraint except when 'f' is the only alternative.
;; Insn attributes which describe the i960.
;; Modscan is not used, since the compiler never emits any of these insns.
(define_attr "type"
  "move,arith,alu2,mult,div,modscan,load,store,branch,call,address,compare,fpload,fpstore,fpmove,fpcvt,fpcc,fpadd,fpmul,fpdiv,multi,misc"
  (const_string "arith"))
; normal register move
(define_expand "movsi"
 [(set (match_operand:SI 0 "general_operand" "")
     (match_operand:SI 1 "general_operand" ""))]
 ""
 {
    if (i960_expand_move(mode, operands[0], operands[1])) 
    DONE;
 })

;; Length (in # of insns).
(define_attr "length" ""
  (cond [(eq_attr "type" "load,fpload")
	      (if_then_else (match_operand 1 "i960_symbolic_memory_operand" "")
			    (const_int 2)
			    (const_int 1))
	 (eq_attr "type" "store,fpstore")
	      (if_then_else (match_operand 0 "i960_symbolic_memory_operand" "")
			    (const_int 2)
			    (const_int 1))
	 (eq_attr "type" "address")
	      (const_int 2)]
	(const_int 1)))

(define_asm_attributes
  [(set_attr "length" "1")
   (set_attr "type" "multi")])

 (define_insn "divsi3"
   [(set (match_operand:SI 0 "register_operand" "=d")
         (div:SI (match_operand:SI 1 "arith_operand" "dI")
                 (match_operand:SI 2 "arith_operand" "dI")))]
   ""
   "divi\t%2,%1,%0"
   [(set_attr "type" "div")])
 (define_insn "udivsi3"
   [(set (match_operand:SI 0 "register_operand" "=d")
         (udiv:SI (match_operand:SI 1 "arith_operand" "dI")
 		 (match_operand:SI 2 "arith_operand" "dI")))]
   ""
   "divo\t%2,%1,%0"
   [(set_attr "type" "div")])
 
 ;; We must use `remi' not `modi' here, to ensure that `%' has the effects
 ;; specified by the ANSI C standard.
 
 (define_insn "modsi3"
   [(set (match_operand:SI 0 "register_operand" "=d")
         (mod:SI (match_operand:SI 1 "arith_operand" "dI")
                 (match_operand:SI 2 "arith_operand" "dI")))]
   ""
   "remi\t%2,%1,%0"
   [(set_attr "type" "div")])

 (define_insn "compare_long_real"
   [(set (reg:CC 36)
 	(compare:CC (match_operand:DF 0 "register_operand" "r")
 		    (match_operand:DF 1 "nonmemory_operand" "rGH")))]
   "TARGET_NUMERICS"
   "cmprl %0,%1"
   [(set_attr "type" "fpcc")])

 (define_insn "flush_register_windows"
   [(unspec_volatile [(const_int 0)] 1)]
   ""
   "flushreg"
   [(set_attr "type" "misc")
    (set_attr "length" "1")])

 (define_insn "nop"
   [(const_int 0)]
   ""
   "")
