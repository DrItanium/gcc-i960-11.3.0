;;- Machine description for Intel 80960 chip for GNU C compiler
;;   Copyright (C) 1992, 1995, 1998, 2001 Free Software Foundation, Inc.
;;   Contributed by Steven McGeady, Intel Corp.
;;   Additional work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson
;;   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.
;;   Updated to gcc 11.3.0 by Joshua Scoggins (2022-2024)

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
(include "constraints.md")
(include "predicates.md")

;; There are very few (4) 'f' registers, they can't be loaded/stored from/to
;; memory, and some instructions explicitly require them, so we get better
;; code by discouraging pseudo-registers from being allocated to them.
;; However, we do want to allow all patterns which can store to them to
;; include them in their constraints, so we always use '*f' in a destination
;; constraint except when 'f' is the only alternative.
;; Insn attributes which describe the i960.
;; Modscan is not used, since the compiler never emits any of these insns.
(define_attr "type"
  "move,arith,alu2,mult,div,modscan,load,store,branch,call,address,compare,fpload,fpstore,fpmove,fpcvt,fpcc,fpadd,fpmul,fpdiv,multi,misc"
  (const_string "arith"))

;; Length (in # of insns).
(define_attr "length" ""
  (cond [(eq_attr "type" "load,fpload")
	      (if_then_else (match_operand 1 "i960_symbolic_memory_operand" "")
			    (const_int 2)
			    (const_int 1))
	 (eq_attr "type" "store,fpstore")
	      (if_then_else (match_operand 0 "i960_symbolic_memory_operand" "")
			    (const_int 2)
			    (const_int 1))
	 (eq_attr "type" "address")
	      (const_int 2)]
	(const_int 1)))

(define_asm_attributes
  [(set_attr "length" "1")
   (set_attr "type" "multi")])

;; (define_function_unit {name} {num-units} {n-users} {test}
;;                       {ready-delay} {issue-delay} [{conflict-list}])

;; The integer ALU
;; (define_cpu_unit "alu" 2 0 (eq_attr "type" "arith,compare,move,address") 1 0)
;; (define_cpu_unit "alu" 2 0 (eq_attr "type" "alu2") 2 0)
;; (define_cpu_unit "alu" 2 0 (eq_attr "type" "mult") 5 0)
;; (define_cpu_unit "alu" 2 0 (eq_attr "type" "div") 35 0)
;; (define_cpu_unit "alu" 2 0 (eq_attr "type" "modscan") 3 0)
;
;;; Memory with load-delay of 1 (i.e., 2 cycle load).
;; (define_cpu_unit "memory" 1 0 (eq_attr "type" "load,fpload") 2 0)
;
;; Floating point operations.
;; (define_cpu_unit "fp" 1 2 (eq_attr "type" "fpmove") 5 0)
;; (define_cpu_unit "fp" 1 2 (eq_attr "type" "fpcvt") 35 0)
;; (define_cpu_unit "fp" 1 2 (eq_attr "type" "fpcc") 10 0)
;; (define_cpu_unit "fp" 1 2 (eq_attr "type" "fpadd") 10 0)
;; (define_cpu_unit "fp" 1 2 (eq_attr "type" "fpmul") 20 0)
;; (define_cpu_unit "fp" 1 2 (eq_attr "type" "fpdiv") 35 0)

;;; @todo describe the aspects of scheduler
;; The i960Sx contains three units but is not superscalar
;; (define_cpu_unit "alu")
;; (define_cpu_unit "fp")
;; ;; bus control unit, has a queue of 
;; (define_cpu_unit "bcu") 
;; 
;; (define_insn_reservation "generic_alu" 1 (eq_attr "type" "arith,compare,move,address") "alu")
;; (define_insn_reservation "generic_alu2" 2 (eq_attr "type" "alu2") "alu")
;; (define_insn_reservation "generic_mult" 5 (eq_attr "type" "mult") "alu")
;; (define_insn_reservation "generic_div" 35 (eq_attr "type" "div") "alu")
;; (define_insn_reservation "generic_modscan" 3 (eq_attr "type" "modscan") )
;; 
;; (define_insn_reservation "delayed_load" 2 (eq_attr "type" "load,fpload") "bcu")
;; (define_insn_reservation "delayed_store" 2 (eq_attr "type" "store,fpstore") "bcu")
;; 
;; ;; Floating point operations.
;; (define_insn_reservation "generic_fpmove" 5 (eq_attr "type" "fpmove") "fp")
;; (define_insn_reservation "generic_fpcvt" 35 (eq_attr "type" "fpcvt") "fp")
;; (define_insn_reservation "generic_fpcc" 10 (eq_attr "type" "fpcc") "fp")
;; (define_insn_reservation "generic_fpadd" 10 (eq_attr "type" "fpadd") "fp")
;; (define_insn_reservation "generic_fpmul" 20 (eq_attr "type" "fpmul") "fp")
;; (define_insn_reservation "generic_fpdiv" 35 (eq_attr "type" "fpdiv") "fp")



;; Compare instructions.
;; This controls RTL generation and register allocation.

;; We generate RTL for comparisons and branches by having the cmpxx 
;; patterns store away the operands.  Then, the scc and bcc patterns
;; emit RTL for both the compare and the branch.
;;
;; We start with the DEFINE_EXPANDs, then DEFINE_INSNs to match
;; the patterns.  Finally, we have the DEFINE_SPLITs for some of the scc
;; insns that actually require more than one machine instruction.

;; Put cmpsi first because it is expected to be the most common.
;; TODO: these are questionable and I think no longer useful but left here as a
;; reference for updating i960.c
;; (define_expand "cmpsi"
;;   [(set (reg:CC 36)
;; 	(compare:CC (match_operand:SI 0 "nonimmediate_operand" "")
;; 		    (match_operand:SI 1 "general_operand" "")))]
;;   ""
;;   "
;; {
;;   i960_compare_op0 = operands[0];
;;   i960_compare_op1 = operands[1];
;;   DONE;
;; }")

;;; Now the DEFINE_INSNs for the compare and scc cases.  First the compares.

(define_insn "*cmpi_insn0"
  [(set (reg:CC 36)
	(compare:CC (match_operand:SI 0 "register_operand" "d")
		    (match_operand:SI 1 "arith_operand" "dI")))]
  ""
  "cmpi	%0,%1"
  [(set_attr "type" "compare")])

(define_insn "*cmpo_insn0"
  [(set (reg:CC_UNS 36)
	(compare:CC_UNS (match_operand:SI 0 "register_operand" "d")
			(match_operand:SI 1 "arith_operand" "dI")))]
  ""
  "cmpo	%0,%1"
  [(set_attr "type" "compare")])

(define_insn "*cmprl_insn0"
  [(set (reg:CC 36)
	(compare:CC (match_operand:DF 0 "register_operand" "r")
		    (match_operand:DF 1 "nonmemory_operand" "rGH")))]
  "TARGET_NUMERICS"
  "cmprl\t%0,%1"
  [(set_attr "type" "fpcc")])

(define_insn "*cmpr_insn0"
  [(set (reg:CC 36)
	(compare:CC (match_operand:SF 0 "register_operand" "r")
		    (match_operand:SF 1 "nonmemory_operand" "rGH")))]
  "TARGET_NUMERICS"
  "cmpr\t%0,%1"
  [(set_attr "type" "fpcc")])

(define_insn "*cmpre"
 [(set (reg:CC 36)
     (compare:CC (match_operand:TF 0 "register_operand" "fGH")
                 (match_operand:TF 1 "nonmemory_operand" "fGH")))]
 "TARGET_NUMERICS"
 "cmpr\t%0,%1"
 [(set_attr "type" "fpcc")])

;; Instruction definitions for branch-on-bit-set and clear insns.

(define_insn "*branch_if_bit_set_insn0"
  [(set (pc)
	(if_then_else
	 (ne (sign_extract:SI (match_operand:SI 0 "register_operand" "d")
			      (const_int 1)
			      (match_operand:SI 1 "arith_operand" "dI"))
	     (const_int 0))
	 (label_ref (match_operand 2 "" ""))
	 (pc)))]
  ""
  ;;"bbs%+	%1,%0,%l2"
  "bbs\t%1,%0,%l2"
  [(set_attr "type" "branch")])

(define_insn "*branch_if_bit_clear_insn0"
  [(set (pc)
	(if_then_else
	 (eq (sign_extract:SI (match_operand:SI 0 "register_operand" "d")
			      (const_int 1)
			      (match_operand:SI 1 "arith_operand" "dI"))
	     (const_int 0))
	 (label_ref (match_operand 2 "" ""))
	 (pc)))]
  ""
  ;;"bbc%+	%1,%0,%l2"
  "bbc\t%1,%0,%l2"
  [(set_attr "type" "branch")])

(define_insn "*branch_if_bit_set_insn1"
  [(set (pc)
	(if_then_else
	 (ne (zero_extract:SI (match_operand:SI 0 "register_operand" "d")
			      (const_int 1)
			      (match_operand:SI 1 "arith_operand" "dI"))
	     (const_int 0))
	 (label_ref (match_operand 2 "" ""))
	 (pc)))]
  ""
  ;;"bbs%+	%1,%0,%l2"
  "bbs\t%1,%0,%l2"
  [(set_attr "type" "branch")])

(define_insn "*branch_if_bit_clear_insn1"
  [(set (pc)
	(if_then_else
	 (eq (zero_extract:SI (match_operand:SI 0 "register_operand" "d")
			      (const_int 1)
			      (match_operand:SI 1 "arith_operand" "dI"))
	     (const_int 0))
	 (label_ref (match_operand 2 "" ""))
	 (pc)))]
  ""
  ;;"bbc%+	%1,%0,%l2"
  "bbc\t%1,%0,%l2"
  [(set_attr "type" "branch")])

;; ??? These will never match.  The LOG_LINKs necessary to make these match
;; are not created by flow.  These remain as a reminder to make this work
;; some day.
;; This is old 3.4.6 code!
;; (define_insn ""
;;   [(set (reg:CC 36)
;; 	(compare (match_operand:SI 0 "arith_operand" "d")
;; 		 (match_operand:SI 1 "arith_operand" "+d")))
;;    (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]
;;   "0"
;;   "cmpinci	%0,%1"
;;   [(set_attr "type" "compare")])
;; 
;; (define_insn ""
;;   [(set (reg:CC_UNS 36)
;; 	(compare (match_operand:SI 0 "arith_operand" "d")
;; 		 (match_operand:SI 1 "arith_operand" "+d")))
;;    (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]
;;   "0"
;;   "cmpinco	%0,%1"
;;   [(set_attr "type" "compare")])
;; 
;; (define_insn ""
;;   [(set (reg:CC 36)
;; 	(compare (match_operand:SI 0 "arith_operand" "d")
;; 		 (match_operand:SI 1 "arith_operand" "+d")))
;;    (set (match_dup 1) (minus:SI (match_dup 1) (const_int 1)))]
;;   "0"
;;   "cmpdeci	%0,%1"
;;   [(set_attr "type" "compare")])
;; 
;; (define_insn ""
;;   [(set (reg:CC_UNS 36)
;; 	(compare (match_operand:SI 0 "arith_operand" "d")
;; 		 (match_operand:SI 1 "arith_operand" "+d")))
;;    (set (match_dup 1) (minus:SI (match_dup 1) (const_int 1)))]
;;   "0"
;;   "cmpdeco	%0,%1"
;;   [(set_attr "type" "compare")])

;; these look to be 3.4.6 specific
;; Templates to store result of condition.
;; '1' is stored if condition is true.
;; '0' is stored if condition is false.
;; These should use predicate "general_operand", since
;; gcc seems to be creating mem references which use these
;; templates.
;;
;; The expressions have been removed except for one for an idea of what was
;; here
;;(define_expand "seq"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(eq:SI (match_dup 1) (const_int 0)))]
;;  ""
;;  "
;;{
;;  operands[1] = i960_gen_compare_reg (EQ, i960_compare_op0, i960_compare_op1);
;;}")

(define_insn "*equals_zero_insn0"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(eq:SI (match_operand:SI 1 "register_operand" "d") (const_int 0)))]
  ""
  "shro	%1,1,%0"
  [(set_attr "type" "alu2")])

(define_insn "*test_integer_insn0"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(match_operator:SI 1 "comparison_operator" [(reg:CC 36) (const_int 0)]))]
  ""
  "test%C1	%0"
  [(set_attr "type" "compare")])


(define_insn "*test_ordinal_insn0"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(match_operator:SI 1 "comparison_operator" [(reg:CC_UNS 36) (const_int 0)]))]
  ""
  "test%C1	%0"
  [(set_attr "type" "compare")])

;; cstoresi4 needs to construct the compare, test, and store setup
;; so it becomes the following:
;;
;; cmp %0, %1, cc ; CC is implied
;; test? cc, %2   ; cc implied
(define_expand "cstoresi4"
 [(set (match_operand:SI 0 "general_operand" "=d")
       (match_operator:SI 1 "comparison_operator"
        [(match_operand:SI 2 "register_operand")
         (match_operand:SI 3 "arith_operand")]))]
  ""
  {
    // since we've emitted the compare we just need to emit the test
    // instruction at this point
    operands[2] = i960_gen_compare_reg(GET_CODE(operands[1]), operands[2], operands[3]);
    operands[3] = const0_rtx;
  }
  )
(define_expand "cstoresf4"
 [(set (match_operand:SI 0 "general_operand" "=d")
       (match_operator:SI 1 "comparison_operator"
        [(match_operand:SF 2 "nonmemory_operand")
         (match_operand:SF 3 "fp_arith_operand")]))]
  "TARGET_NUMERICS"
  {
    // since we've emitted the compare we just need to emit the test
    // instruction at this point
    operands[2] = i960_gen_compare_reg(GET_CODE(operands[1]), operands[2], operands[3]);
    operands[3] = const0_rtx;
  }
  )
(define_expand "cstoredf4"
 [(set (match_operand:SI 0 "general_operand" "=d")
       (match_operator:SI 1 "comparison_operator"
        [(match_operand:DF 2 "nonmemory_operand")
         (match_operand:DF 3 "fp_arith_operand")]))]
  "TARGET_NUMERICS"
  {
    // since we've emitted the compare we just need to emit the test
    // instruction at this point
    operands[2] = i960_gen_compare_reg(GET_CODE(operands[1]), operands[2], operands[3]);
    operands[3] = const0_rtx;
  }
  )
(define_expand "cstoretf4"
 [(set (match_operand:SI 0 "general_operand" "=d")
       (match_operator:SI 1 "comparison_operator"
        [(match_operand:TF 2 "nonmemory_operand")
         (match_operand:TF 3 "fp_arith_operand")]))]
  "TARGET_NUMERICS"
  {
    // since we've emitted the compare we just need to emit the test
    // instruction at this point
    operands[2] = i960_gen_compare_reg(GET_CODE(operands[1]), operands[2], operands[3]);
    operands[3] = const0_rtx;
  }
  )
;; cbranchsi4 is always emitting COBR compare and branch operations after a
;; compare as well
(define_expand "cbranchsi4"
    [(set (pc)
       (if_then_else (match_operator 0 "comparison_operator"
                        [(match_operand:SI 1 "nonmemory_operand" "")
                         (match_operand:SI 2 "arith_operand" "")])
                  (pc)
                  (label_ref (match_operand 3 "" ""))))]
""
{
    operands[1] = i960_gen_compare_reg(GET_CODE(operands[0]), operands[1], operands[2]);
    operands[2] = const0_rtx;
})

(define_expand "cbranchsf4"
    [(set (pc)
       (if_then_else (match_operator 0 "comparison_operator"
                        [(match_operand:SF 1 "nonmemory_operand" "")
                         (match_operand:SF 2 "fp_arith_operand" "")])
                  (pc)
                  (label_ref (match_operand 3 "" ""))))]
"TARGET_NUMERICS"
{
    operands[1] = i960_gen_compare_reg(GET_CODE(operands[0]), operands[1], operands[2]);
    operands[2] = const0_rtx;
})

(define_expand "cbranchdf4"
    [(set (pc)
       (if_then_else (match_operator 0 "comparison_operator"
                        [(match_operand:DF 1 "nonmemory_operand" "")
                         (match_operand:DF 2 "fp_arith_operand" "")])
                  (pc)
                  (label_ref (match_operand 3 "" ""))))]
"TARGET_NUMERICS"
{
    operands[1] = i960_gen_compare_reg(GET_CODE(operands[0]), operands[1], operands[2]);
    operands[2] = const0_rtx;
})

(define_expand "cbranchtf4"
    [(set (pc)
       (if_then_else (match_operator 0 "comparison_operator"
                        [(match_operand:TF 1 "nonmemory_operand" "")
                         (match_operand:TF 2 "fp_arith_operand" "")])
                  (pc)
                  (label_ref (match_operand 3 "" ""))))]
"TARGET_NUMERICS"
{
    operands[1] = i960_gen_compare_reg(GET_CODE(operands[0]), operands[1], operands[2]);
    operands[2] = const0_rtx;
})
;; These control RTL generation for conditional jump insns
;; and match them for register allocation.
;; these seem to be gcc 3.4.6 specific but components necessary for i960.c are
;; left here commented out
;; (define_expand "bne"
;;   [(set (pc)
;; 	(if_then_else (ne (match_dup 1)
;; 			  (const_int 0))
;; 		      (label_ref (match_operand 0 "" ""))
;; 		      (pc)))]
;;   ""
;;   "{ operands[1] = i960_gen_compare_reg (NE, i960_compare_op0, i960_compare_op1); }")
;; 

;; Now the normal branch insns (forward and reverse).

(define_insn "*if_cond_then_jump_else_fallthrough_insn"
  [(set (pc)
	(if_then_else (match_operator 0 "comparison_operator"
				      [(reg:CC 36) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  ""
  ;; "b%C0%+ %l1"
  "b%C0\t%l1"
  [(set_attr "type" "branch")])


(define_insn "*if_cond_then_fallthrough_else_jump_insn"
  [(set (pc)
	(if_then_else (match_operator 0 "comparison_operator"
				      [(reg:CC 36) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 1 "" ""))))]
  ""
  ;; "b%I0%+ %l1"
  "b%I0\t%l1"
  [(set_attr "type" "branch")])

(define_insn "*if_unsigned_cond_then_jump_else_fallthrough"
  [(set (pc)
	(if_then_else (match_operator 0 "comparison_operator"
				      [(reg:CC_UNS 36) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  ""
  ;; "b%C0%+ %l1"
  "b%C0\t%l1"
  [(set_attr "type" "branch")])

(define_insn "*if_unsigned_cond_then_fallthrough_else_jump"
  [(set (pc)
	(if_then_else (match_operator 0 "comparison_operator"
				      [(reg:CC_UNS 36) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 1 "" ""))))]
  ""
  ;; "b%I0%+ %l1"
  "b%I0\t%l1"
  [(set_attr "type" "branch")])

;; generic expansion for conditional branches
;; these do work but can cause extraneous instructions to be inserted! 
;;(define_insn ""
;;  [(set (pc)
;;	(if_then_else
;;	 (match_operator 0 "comparison_operator"
;;			 [(match_operand:SI 1 "nonmemory_operand" "d")
;;			  (match_operand:SI 2 "arith_operand" "dI")])
;;	 (label_ref (match_operand 3 "" ""))
;;	 (pc)))]
;;  ""
;;  ;; "cmp%S0%B0%R0%+	%2,%1,%l3"
;;  "cmp%S0%B0%R0\t%2,%1,%l3"
;;  [(set_attr "type" "branch")])
;;
;;(define_insn ""
;;  [(set (pc)
;;	(if_then_else
;;	 (match_operator 0 "comparison_operator"
;;			 [(match_operand:SI 1 "nonmemory_operand" "d")
;;			  (match_operand:SI 2 "arith_operand" "dI")])
;;	 (pc)
;;	 (label_ref (match_operand 3 "" ""))))]
;;  ""
;;  ;;"cmp%S0%B0%X0%+	%2,%1,%l3"
;;  "cmp%S0%B0%X0\t%2,%1,%l3"
;;  [(set_attr "type" "branch")])

;; Now the trap instructions.  The i960 appears to only have conditional
;; traps...

(define_insn "trap"
  [(trap_if (const_int 1) 
            (const_int 0))]
  ""
  "cmpo g0,g0
faulte.t")

(define_insn "*compare_and_trap_insn_signed"
  [(trap_if (match_operator 0 "comparison_operator"
	     [(reg:CC 36) (const_int 0)]) 
	    (match_operand 1 "const_int_operand" "i"))]
  ""
  "fault%C0.f")

(define_insn "*compare_and_trap_insn_unsigned"
  [(trap_if (match_operator 0 "comparison_operator"
	     [(reg:CC_UNS 36) (const_int 0)]) 
	    (match_operand 1 "const_int_operand" "i"))]
  ""
  "fault%C0.f")

;; Normal move instructions.
;; This code is based on the sparc machine description.
;; if the emit_move_sequence is successful then we do not perform any code
;; generation and return
(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand" "")
	(match_operand:SI 1 "general_operand" ""))]
  ""
{
  if (i960_emit_move_sequence (operands, SImode))
    DONE;
})

;; The store case can not be separate, because reload may convert a register
;; to register move insn to a store (or load) insn without rerecognizing
;; the insn.

;; The i960 does not have any store constant to memory instruction.  However,
;; the calling convention is defined so that the arg pointer when it is not
;; overwise being used is zero.  Thus, we can handle store zero to memory
;; by storing an unused arg pointer.  The arg pointer will be unused if
;; current_function_args_size is zero and this is not a stdarg
;; function.  This value of the former variable is not valid until after
;; all rtl generation is complete, including function inlining (because a
;; function that doesn't need an arg pointer may be inlined into a function
;; that does need an arg pointer), so we must also check that
;; currently_expanding_to_rtl is zero.

;; if it is constant to register then it should be an ldconst
;; if it is register to register then it should be a move
;; If it is a memory to register then it should be a load
;; IF it is a register to memory then it should be a store

;; This the idea we should be rolling with to make our lives much easier to work with
;;

(define_insn "*movsi2_v0"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d,d,m")
	(match_operand:SI 1 "general_operand" "dI,i,m,dJ"))]
  "i960_can_use_g14_for_zero_store()
   && (register_operand (operands[0], SImode)
       || register_operand (operands[1], SImode)
       || operands[1] == const0_rtx)"
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"mov	%1,%0\";
    case 1:
      return i960_output_ldconst (operands[0], operands[1]);
    case 2:
      return \"ld	%1,%0\";
    case 3:
      if (operands[1] == const0_rtx)
	return \"st	g14,%0\";
      return \"st	%1,%0\";      
    default:
      abort();
    }
}"
  [(set_attr "type" "move,address,load,store")
   (set_attr "length" "*,3,*,*")])

(define_insn "*movsi2_v1"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d,d,m")
	(match_operand:SI 1 "general_operand" "dI,i,m,d"))]
  "i960_cannot_use_g14_for_zero_store()
   && (register_operand (operands[0], SImode)
       || register_operand (operands[1], SImode))"
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"mov	%1,%0\";
    case 1:
      return i960_output_ldconst (operands[0], operands[1]);
    case 2:
      return \"ld	%1,%0\";
    case 3:
      return \"st	%1,%0\";      
    default:
      abort();
    }
}"
  [(set_attr "type" "move,address,load,store")
   (set_attr "length" "*,3,*,*")])

(define_expand "movhi"
  [(set (match_operand:HI 0 "general_operand" "")
	(match_operand:HI 1 "general_operand" ""))]
  ""
{
  if (i960_emit_move_sequence (operands, HImode))
    DONE;
})

;; Special pattern for zero stores to memory for functions which don't use
;; the arg pointer.

;; The store case can not be separate.  See above.
(define_insn "*movhi2_v0"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,d,d,m")
	(match_operand:HI 1 "general_operand" "dI,i,m,dJ"))]
  "i960_can_use_g14_for_zero_store()
   && (register_operand (operands[0], HImode)
       || register_operand (operands[1], HImode)
       || operands[1] == const0_rtx)"
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"mov	%1,%0\";
    case 1:
      return i960_output_ldconst (operands[0], operands[1]);
    case 2:
      return \"ldos	%1,%0\";
    case 3:
      if (operands[1] == const0_rtx)
	return \"stos	g14,%0\";
      return \"stos	%1,%0\";
    default:
      abort();
    }
}"
  [(set_attr "type" "move,misc,load,store")
   (set_attr "length" "*,3,*,*")])

;; The store case can not be separate.  See above.
(define_insn "*movhi2_v1"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,d,d,m")
	(match_operand:HI 1 "general_operand" "dI,i,m,d"))]
  "i960_cannot_use_g14_for_zero_store()
   && (register_operand (operands[0], HImode)
       || register_operand (operands[1], HImode))"
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"mov	%1,%0\";
    case 1:
      return i960_output_ldconst (operands[0], operands[1]);
    case 2:
      return \"ldos	%1,%0\";
    case 3:
      return \"stos	%1,%0\";
    default:
      abort();
    }
}"
  [(set_attr "type" "move,misc,load,store")
   (set_attr "length" "*,3,*,*")])

(define_expand "movqi"
  [(set (match_operand:QI 0 "general_operand" "")
	(match_operand:QI 1 "general_operand" ""))]
  ""
{
  if (i960_emit_move_sequence (operands, QImode))
    DONE;
})

;; The store case can not be separate.  See comment above.
(define_insn "*movqi2_v0"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,d,d,m")
	(match_operand:QI 1 "general_operand" "dI,i,m,dJ"))]
  "i960_can_use_g14_for_zero_store()
   && (register_operand (operands[0], QImode)
       || register_operand (operands[1], QImode)
       || operands[1] == const0_rtx)"
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"mov	%1,%0\";
    case 1:
      return i960_output_ldconst (operands[0], operands[1]);
    case 2:
      return \"ldob	%1,%0\";
    case 3:
      if (operands[1] == const0_rtx)
	return \"stob	g14,%0\";
      return \"stob	%1,%0\";
    default:
      abort();
    }
}"
  [(set_attr "type" "move,misc,load,store")
   (set_attr "length" "*,3,*,*")])

;; The store case can not be separate.  See comment above.
(define_insn "*movqi2_v1"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,d,d,m")
	(match_operand:QI 1 "general_operand" "dI,i,m,d"))]
  "i960_cannot_use_g14_for_zero_store()
   && (register_operand (operands[0], QImode)
       || register_operand (operands[1], QImode))"
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"mov	%1,%0\";
    case 1:
      return i960_output_ldconst (operands[0], operands[1]);
    case 2:
      return \"ldob	%1,%0\";
    case 3:
      return \"stob	%1,%0\";
    default:
      abort();
    }
}"
  [(set_attr "type" "move,misc,load,store")
   (set_attr "length" "*,3,*,*")])

(define_expand "movdi"
  [(set (match_operand:DI 0 "general_operand" "")
	(match_operand:DI 1 "general_operand" ""))]
  ""
{
  if (i960_emit_move_sequence (operands, DImode))
    DONE;
})

;; The store case can not be separate.  See comment above.
(define_insn "*movdi2_v0"
  [(set (match_operand:DI 0 "nonimmediate_operand" "=d,d,d,d,m,o")
	(match_operand:DI 1 "general_operand"          " d,I,i,m,d,J"))]
  "i960_can_use_g14_for_zero_store()
   && (register_operand (operands[0], DImode)
       || register_operand (operands[1], DImode)
       || operands[1] == const0_rtx)"
  "*
{
  switch (which_alternative)
    {
    case 0:
    case 1:
    case 3:
    case 4:
      return i960_output_move_double (operands[0], operands[1]);
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 5:
       return i960_output_move_double_zero (operands[0]);
    default:
      abort();
    }
}"
  [(set_attr "type" "move,move,load,load,store,store")])

;; The store case can not be separate.  See comment above.
(define_insn "*movdi2_v1"
  [(set (match_operand:DI 0 "nonimmediate_operand" "=d,d,d,d,m")
	(match_operand:DI 1 "general_operand"          " d,I,i,m,d"))]
  "i960_cannot_use_g14_for_zero_store()
   && (register_operand (operands[0], DImode)
       || register_operand (operands[1], DImode))"
  "*
{
  switch (which_alternative)
    {
    case 0:
    case 1:
    case 3:
    case 4:
      return i960_output_move_double (operands[0], operands[1]);
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    default:
      abort();
    }
}"
  [(set_attr "type" "move,move,load,load,store")])

(define_insn "*movdi2_unaligned"
  [(set (match_operand:DI 0 "nonimmediate_operand" "=d,m")
	(match_operand:DI 1 "register_operand" "d,d"))
   (clobber (match_scratch:SI 2 "=X,&d"))]
  ""
  "*
{
  if (which_alternative == 0)
    return i960_output_move_double (operands[0], operands[1]);
    
  operands[3] = gen_rtx_MEM (word_mode, operands[2]);
  operands[4] = adjust_address (operands[3], word_mode, UNITS_PER_WORD);
  return \"lda	%0,%2\;st	%1,%3\;st	%D1,%4 # unaligned di store 0\";
}"
  [(set_attr "type" "move,store")])

(define_expand "movti"
  [(set (match_operand:TI 0 "general_operand" "")
	(match_operand:TI 1 "general_operand" ""))]
  ""
{
  if (i960_emit_move_sequence (operands, TImode))
    DONE;
})

;; The store case can not be separate.  See comment above.
(define_insn "*movti2_v0"
  [(set (match_operand:TI 0 "nonimmediate_operand" "=d,d,d,d,m,o")
	(match_operand:TI 1 "general_operand" "d,I,i,m,d,J"))]
  "i960_can_use_g14_for_zero_store()
   && (register_operand (operands[0], TImode)
       || register_operand (operands[1], TImode)
       || operands[1] == const0_rtx)"
  "*
{
  switch (which_alternative)
    {
    case 0:
    case 1:
    case 3:
    case 4:
      return i960_output_move_quad (operands[0], operands[1]);
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 5:
      return i960_output_move_quad_zero (operands[0]);
    default:
      abort();
    }
}"
  [(set_attr "type" "move,move,load,load,store,store")])

;; The store case can not be separate.  See comment above.
(define_insn "*movti2_v1"
  [(set (match_operand:TI 0 "nonimmediate_operand" "=d,d,d,d,m")
	(match_operand:TI 1 "general_operand" "d,I,i,m,d"))]
  "i960_cannot_use_g14_for_zero_store()
   && (register_operand (operands[0], TImode)
       || register_operand (operands[1], TImode))"
  "*
{
  switch (which_alternative)
    {
    case 0:
    case 1:
    case 3:
    case 4:
      return i960_output_move_quad (operands[0], operands[1]);
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    default:
      abort();
    }
}"
  [(set_attr "type" "move,move,load,load,store")])

(define_insn "*movti2_unaligned"
  [(set (match_operand:TI 0 "nonimmediate_operand" "=d,m")
	(match_operand:TI 1 "register_operand" "d,d"))
   (clobber (match_scratch:SI 2 "=X,&d"))]
  ""
  "*
{
  if (which_alternative == 0)
    return i960_output_move_quad (operands[0], operands[1]);

  operands[3] = gen_rtx_MEM (word_mode, operands[2]);
  operands[4] = adjust_address (operands[3], word_mode, UNITS_PER_WORD);
  operands[5] = adjust_address (operands[4], word_mode, UNITS_PER_WORD);
  operands[6] = adjust_address (operands[5], word_mode, UNITS_PER_WORD);
  return \"lda	%0,%2\;st	%1,%3\;st	%D1,%4\;st	%E1,%5\;st	%F1,%6 # unaligned store quad reg 0\";
}"
  [(set_attr "type" "move,store")])
;; this is a legit expand
;; TODO implement store and load multiple
(define_expand "store_multiple"
  [(match_par_dup 3 [(set (match_operand:SI 0 "" "") ;; - dest
                          (match_operand:SI 1 "" "")) ;; - src
                     (use (match_operand:SI 2 "" ""))])] ;; - nregs
  "reload_completed"
{
  int offset = 0;

  if (GET_CODE (operands[0]) != MEM
      || GET_CODE (operands[1]) != REG
      || GET_CODE (operands[2]) != CONST_INT)
    FAIL;

  int count = INTVAL (operands[2]);
  if (count > 12)
    FAIL;

  int regno = REGNO (operands[1]);
  while (count >= 4 && isQuadRegisterAligned(regno)) {
    emit_move_insn (adjust_address (operands[0], TImode, offset),
            gen_rtx_REG (TImode, regno));
    count -= 4;
    regno += 4;
    offset += 16;
  }
  while (count >= 2 && isLongRegisterAligned(regno)) {
      emit_move_insn (adjust_address (operands[0], DImode, offset),
              gen_rtx_REG (DImode, regno));
      count -= 2;
      regno += 2;
      offset += 8;
  }
  while (count > 0)
  {
      emit_move_insn (adjust_address (operands[0], SImode, offset),
              gen_rtx_REG (SImode, regno));
      count -= 1;
      regno += 1;
      offset += 4;
  }
  DONE;
})


;; Floating point move insns

(define_expand "movdf"
  [(set (match_operand:DF 0 "general_operand" "")
	(match_operand:DF 1 "fpmove_src_operand" ""))]
  ""
{
  if (i960_emit_move_sequence (operands, DFmode))
    DONE;
})

(define_insn ""
  [(set (match_operand:DF 0 "nonimmediate_operand" "=r,*f,d,d,m,o")
	(match_operand:DF 1 "fpmove_src_operand" "r,GH,F,m,d,G"))]
  "i960_can_use_g14_for_zero_store()
   && (register_operand (operands[0], DFmode)
       || register_operand (operands[1], DFmode)
       || operands[1] == CONST0_RTX (DFmode))"
  "*
{
  switch (which_alternative)
    {
    case 0:
      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))
	return \"movrl	%1,%0\";
      else
	return \"movl	%1,%0\";
    case 1:
      return \"movrl	%1,%0\";
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 3:
      return \"ldl	%1,%0\";
    case 4:
      return \"stl	%1,%0\";
    case 5:
      operands[1] = adjust_address (operands[0], VOIDmode, 4);
      return \"st	g14,%0\;st	g14,%1\";
    default:
      abort();
    }
}"
  [(set_attr "type" "move,move,load,fpload,fpstore,fpstore")])

(define_insn ""
  [(set (match_operand:DF 0 "nonimmediate_operand" "=r,*f,d,d,m")
	(match_operand:DF 1 "fpmove_src_operand" "r,GH,F,m,d"))]
  "i960_cannot_use_g14_for_zero_store()
   && (register_operand (operands[0], DFmode)
       || register_operand (operands[1], DFmode))"
  "*
{
  switch (which_alternative)
    {
    case 0:
      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))
	return \"movrl	%1,%0\";
      else
	return \"movl	%1,%0\";
    case 1:
      return \"movrl	%1,%0\";
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 3:
      return \"ldl	%1,%0\";
    case 4:
      return \"stl	%1,%0\";
    default:
      abort();
    }
}"
  [(set_attr "type" "move,move,load,fpload,fpstore")])

(define_expand "movsf"
  [(set (match_operand:SF 0 "general_operand" "")
	(match_operand:SF 1 "fpmove_src_operand" ""))]
  ""
{
  if (i960_emit_move_sequence (operands, SFmode))
    DONE;
})

(define_insn ""
  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,*f,d,d,m")
	(match_operand:SF 1 "fpmove_src_operand" "r,GH,F,m,dG"))]
  "i960_can_use_g14_for_zero_store()
   && (register_operand (operands[0], SFmode)
       || register_operand (operands[1], SFmode)
       || operands[1] == CONST0_RTX (SFmode))"
  "*
{
  switch (which_alternative)
    {
    case 0:
        if (FP_REG_P (operands[0]) || FP_REG_P (operands[1])) {
            return \"movr	%1,%0\";
        } else {
            return \"mov	%1,%0\";
        }
    case 1:
      return \"movr	%1,%0\";
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 3:
      return \"ld	%1,%0\";
    case 4:
      if (operands[1] == CONST0_RTX (SFmode)) {
          return \"st	g14,%0\";
      }
      return \"st	%1,%0\";
    default:
      abort();
    }
}"
  [(set_attr "type" "move,move,load,fpload,fpstore")])

(define_insn ""
  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,*f,d,d,m")
	(match_operand:SF 1 "fpmove_src_operand" "r,GH,F,m,d"))]
  "i960_cannot_use_g14_for_zero_store()
   && (register_operand (operands[0], SFmode)
       || register_operand (operands[1], SFmode))"
  "*
{
  switch (which_alternative)
    {
    case 0:
      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1])) {
	    return \"movr	%1,%0\";
      } else {
	    return \"mov	%1,%0\";
      }
    case 1:
      return \"movr	%1,%0\";
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 3:
      return \"ld	%1,%0\";
    case 4:
      return \"st	%1,%0\";
    default:
      abort();
    }
}"
  [(set_attr "type" "move,move,load,fpload,fpstore")])

;; Mixed-mode moves with sign and zero-extension.

;; Note that the one starting from HImode comes before those for QImode
;; so that a constant operand will match HImode, not QImode.

(define_expand "extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(sign_extend:SI
	 (match_operand:HI 1 "nonimmediate_operand" "")))]
 ""
 "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx temp = gen_reg_rtx (SImode);
      rtx shift_16 = GEN_INT (16);
      int op1_subreg_byte = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_byte = SUBREG_BYTE (operand1);
	  op1_subreg_byte /= GET_MODE_SIZE (SImode);
	  op1_subreg_byte *= GET_MODE_SIZE (SImode);
	  operand1 = SUBREG_REG (operand1);
	}
      if (GET_MODE (operand1) != SImode)
	operand1 = gen_rtx_SUBREG (SImode, operand1, op1_subreg_byte);

      emit_insn (gen_ashlsi3 (temp, operand1, shift_16));
      emit_insn (gen_ashrsi3 (operand0, temp, shift_16));
      DONE;
    }
}")

(define_insn "*signextend_hi2si_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(sign_extend:SI (match_operand:HI 1 "memory_operand" "m")))]
  ""
  "ldis	%1,%0"
  [(set_attr "type" "load")])

(define_expand "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx temp = gen_reg_rtx (SImode);
      rtx shift_24 = GEN_INT (24);
      int op1_subreg_byte = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_byte = SUBREG_BYTE (operand1);
	  op1_subreg_byte /= GET_MODE_SIZE (SImode);
	  op1_subreg_byte *= GET_MODE_SIZE (SImode);
	  operand1 = SUBREG_REG (operand1);
	}
      if (GET_MODE (operand1) != SImode)
	operand1 = gen_rtx_SUBREG( SImode, operand1, op1_subreg_byte);

      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));
      emit_insn (gen_ashrsi3 (operand0, temp, shift_24));
      DONE;
    }
}")

(define_insn "*signextend_qi2si_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(sign_extend:SI (match_operand:QI 1 "memory_operand" "m")))]
  ""
  "ldib	%1,%0"
  [(set_attr "type" "load")])

(define_expand "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI
	 (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx temp = gen_reg_rtx (SImode);
      rtx shift_24 = GEN_INT (24);
      int op0_subreg_byte = 0;
      int op1_subreg_byte = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_byte = SUBREG_BYTE (operand1);
	  op1_subreg_byte /= GET_MODE_SIZE (SImode);
	  op1_subreg_byte *= GET_MODE_SIZE (SImode);
	  operand1 = SUBREG_REG (operand1);
	}
      if (GET_MODE (operand1) != SImode)
	operand1 = gen_rtx_SUBREG( SImode, operand1, op1_subreg_byte);

      if (GET_CODE (operand0) == SUBREG)
	{
	  op0_subreg_byte = SUBREG_BYTE (operand0);
	  op0_subreg_byte /= GET_MODE_SIZE (SImode);
	  op0_subreg_byte *= GET_MODE_SIZE (SImode);
	  operand0 = SUBREG_REG (operand0);
	}
      if (GET_MODE (operand0) != SImode)
	operand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_byte);

      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));
      emit_insn (gen_ashrsi3 (operand0, temp, shift_24));
      DONE;
    }
}")

(define_insn "*signextend_qi2hi_insn"
  [(set (match_operand:HI 0 "register_operand" "=d")
	(sign_extend:HI (match_operand:QI 1 "memory_operand" "m")))]
  ""
  "ldib	%1,%0"
  [(set_attr "type" "load")])

(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(zero_extend:SI
	 (match_operand:HI 1 "nonimmediate_operand" "")))]
 ""
 "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx temp = gen_reg_rtx (SImode);
      rtx shift_16 = GEN_INT (16);
      int op1_subreg_byte = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_byte = SUBREG_BYTE (operand1);
	  op1_subreg_byte /= GET_MODE_SIZE (SImode);
	  op1_subreg_byte *= GET_MODE_SIZE (SImode);
	  operand1 = SUBREG_REG (operand1);
	}
      if (GET_MODE (operand1) != SImode)
	operand1 = gen_rtx_SUBREG( SImode, operand1, op1_subreg_byte);

      emit_insn (gen_ashlsi3 (temp, operand1, shift_16));
      emit_insn (gen_lshrsi3 (operand0, temp, shift_16));
      DONE;
    }
}")

(define_insn "*insn_hi2si_zeroextend"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(zero_extend:SI (match_operand:HI 1 "memory_operand" "m")))]
  ""
  "ldos	%1,%0"
  [(set_attr "type" "load")])

;; Using shifts here generates much better code than doing an `and 255'.
;; This is mainly because the `and' requires loading the constant separately,
;; the constant is likely to get optimized, and then the compiler can't
;; optimize the `and' because it doesn't know that one operand is a constant.

(define_expand "zero_extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx temp = gen_reg_rtx (SImode);
      rtx shift_24 = GEN_INT (24);
      int op1_subreg_byte = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
          op1_subreg_byte = SUBREG_BYTE (operand1);
          op1_subreg_byte /= GET_MODE_SIZE (SImode);
          op1_subreg_byte *= GET_MODE_SIZE (SImode);
          operand1 = SUBREG_REG (operand1);
	}
      if (GET_MODE (operand1) != SImode)
	operand1 = gen_rtx_SUBREG( SImode, operand1, op1_subreg_byte);

      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));
      emit_insn (gen_lshrsi3 (operand0, temp, shift_24));
      DONE;
    }
}")

(define_insn "*zeroextend_qi2si_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(zero_extend:SI (match_operand:QI 1 "memory_operand" "m")))]
  ""
  "ldob	%1,%0"
  [(set_attr "type" "load")])

(define_expand "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "")
	(zero_extend:HI
	 (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx temp = gen_reg_rtx (SImode);
      rtx shift_24 = GEN_INT (24);
      int op0_subreg_byte = 0;
      int op1_subreg_byte = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_byte = SUBREG_BYTE (operand1);
	  operand1 = SUBREG_REG (operand1);
	}
      if (GET_MODE (operand1) != SImode)
	operand1 = gen_rtx_SUBREG( SImode, operand1, op1_subreg_byte);

      if (GET_CODE (operand0) == SUBREG)
	{
	  op0_subreg_byte = SUBREG_BYTE (operand0);
	  operand0 = SUBREG_REG (operand0);
	}
      if (GET_MODE (operand0) != SImode)
	operand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_byte);

      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));
      emit_insn (gen_lshrsi3 (operand0, temp, shift_24));
      DONE;
    }
}")

(define_insn "*zeroextend_qi2hi_insn"
  [(set (match_operand:HI 0 "register_operand" "=d")
	(zero_extend:HI (match_operand:QI 1 "memory_operand" "m")))]
  ""
  "ldob	%1,%0"
  [(set_attr "type" "load")])

;; Conversions between float and double.

(define_insn "extendsfdf2"
  [(set (match_operand:DF 0 "register_operand" "=*f,d")
	(float_extend:DF (match_operand:SF 1 "fp_arith_operand" "dGH,fGH")))]
  "TARGET_NUMERICS"
  "@
  movr	%1,%0
  movrl	%1,%0"
  [(set_attr "type" "fpmove")])

(define_insn "truncdfsf2"
  [(set (match_operand:SF 0 "register_operand" "=d")
	(float_truncate:SF
	 (match_operand:DF 1 "fp_arith_operand" "fGH")))]
  "TARGET_NUMERICS"
  "movr	%1,%0"
  [(set_attr "type" "fpmove")])

;; Conversion between fixed point and floating point.

(define_insn "floatsidf2"
  [(set (match_operand:DF 0 "register_operand" "=f")
	(float:DF (match_operand:SI 1 "register_operand" "d")))]
  "TARGET_NUMERICS"
  "cvtir	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "floatsisf2"
  [(set (match_operand:SF 0 "register_operand" "=d*f")
	(float:SF (match_operand:SI 1 "register_operand" "d")))]
  "TARGET_NUMERICS"
  "cvtir	%1,%0"
  [(set_attr "type" "fpcvt")])

;; Convert a float to an actual integer.
;; Truncation is performed as part of the conversion.
;; The i960 requires conversion from DFmode to DImode to make
;; unsigned conversions work properly.

(define_insn "fixuns_truncdfdi2"
  [(set (match_operand:DI 0 "register_operand" "=d")
	(unsigned_fix:DI (fix:DF (match_operand:DF 1 "fp_arith_operand" "fGH"))))]
  "TARGET_NUMERICS"
  "cvtzril	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "fixuns_truncsfdi2"
  [(set (match_operand:DI 0 "register_operand" "=d")
	(unsigned_fix:DI (fix:SF (match_operand:SF 1 "fp_arith_operand" "fGH"))))]
  "TARGET_NUMERICS"
  "cvtzril	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "fix_truncdfsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(fix:SI (fix:DF (match_operand:DF 1 "fp_arith_operand" "fGH"))))]
  "TARGET_NUMERICS"
  "cvtzri	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_expand "fixuns_truncdfsi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(unsigned_fix:SI (fix:DF (match_operand:DF 1 "fp_arith_operand" ""))))]
  "TARGET_NUMERICS"
  "
{
  rtx temp = gen_reg_rtx (DImode);
  emit_insn (gen_rtx_SET (temp, gen_rtx_UNSIGNED_FIX (DImode, gen_rtx_FIX (DFmode, operands[1]))));
  emit_insn (gen_rtx_SET (operands[0], gen_rtx_SUBREG (SImode, temp, 0)));
  DONE;
}")

(define_insn "fix_truncsfsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(fix:SI (fix:SF (match_operand:SF 1 "fp_arith_operand" "dfGH"))))]
  "TARGET_NUMERICS"
  "cvtzri	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_expand "fixuns_truncsfsi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(unsigned_fix:SI (fix:SF (match_operand:SF 1 "fp_arith_operand" ""))))]
  "TARGET_NUMERICS"
  "
{
  rtx temp = gen_reg_rtx (DImode);
  emit_insn (gen_rtx_SET (temp, gen_rtx_UNSIGNED_FIX (DImode, gen_rtx_FIX (SFmode, operands[1]))));
  emit_insn (gen_rtx_SET (operands[0], gen_rtx_SUBREG (SImode, temp, 0)));
  DONE;
}")

;; Arithmetic instructions.

(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(minus:SI (match_operand:SI 1 "arith_operand" "dI")
		  (match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "subo	%2,%1,%0")

;; the use of the bypass functions is to trigger a performance optimization
;; where if src2 in the previous instruction is used then make sure it is found
;; in src1. This eliminates a cycle in the pipeline
(define_insn "addsi3_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(plus:SI (match_operand:SI 1 "signed_arith_operand" "%dI")
		 (match_operand:SI 2 "signed_arith_operand" "dIK")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
    return \"subo	%n2,%1,%0\";
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"addo	%2,%1,%0\";
  return \"addo	%1,%2,%0\";
}")
(define_insn "addsi3_lda"
 [(set (match_operand:SI 0 "register_operand" "=d")
     (plus:SI (match_operand:SI 1 "register_operand" "d")
              (match_operand:SI 2 "lda_literal" "L")))]
 ""
 "lda\t%a2(%1),%0")

(define_expand "addsi3"
 [(set (match_operand:SI 0 "register_operand" "")
     (plus:SI (match_operand:SI 1 "arith_operand" "")
              (match_operand:SI 2 "arith_operand" "")))]
 ""
 "")
       

(define_insn "mulsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(mult:SI (match_operand:SI 1 "arith_operand" "%dI")
		 (match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "*
{
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"mulo	%2,%1,%0\";
  return \"mulo	%1,%2,%0\";
}"
  [(set_attr "type" "mult")])

(define_insn "umulsidi3"
  [(set (match_operand:DI 0 "register_operand" "=d")
	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "d"))
		 (zero_extend:DI (match_operand:SI 2 "register_operand" "d"))))]
  ""
  "*
{
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"emul	%2,%1,%0\";
  return \"emul	%1,%2,%0\";
}"
  [(set_attr "type" "mult")])

(define_insn ""
  [(set (match_operand:DI 0 "register_operand" "=d")
	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "%d"))
		 (match_operand:SI 2 "literal" "I")))]
  ""
  "*
{
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"emul	%2,%1,%0\";
  return \"emul	%1,%2,%0\";
}"
  [(set_attr "type" "mult")])

;; This goes after the move/add/sub/mul instructions  
;; because those instructions are better when they apply.

(define_insn "*load_address_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(match_operand:SI 1 "address_operand" "p"))]
  ""
  "lda	%a1,%0"
  [(set_attr "type" "load")])

;; This will never be selected because of an "optimization" that GCC does.
;; It always converts divides by a power of 2 into a sequence of instructions
;; that does a right shift, and then corrects the result if it was negative.

 (define_insn "*shrdi_insn"
   [(set (match_operand:SI 0 "register_operand" "=d")
         (div:SI (match_operand:SI 1 "arith_operand" "dI")
                 (match_operand:SI 2 "power2_operand" "nI")))]
   ""
   "*{
 	operands[2] = GEN_INT (i960_bitpos (INTVAL (operands[2])));
 	return \"shrdi	%2,%1,%0\";
   }"
 )

(define_insn "divsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
        (div:SI (match_operand:SI 1 "arith_operand" "dI")
                (match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "divi	%2,%1,%0"
  [(set_attr "type" "div")])

(define_insn "udivsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
        (udiv:SI (match_operand:SI 1 "arith_operand" "dI")
		 (match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "divo	%2,%1,%0"
  [(set_attr "type" "div")])

;; We must use `remi' not `modi' here, to ensure that `%' has the effects
;; specified by the ANSI C standard. However it does lead us having an integer
;; overflow problem. Problem is, that if we mask integer overflow then we take
;; a 14 cycle penalty when the overflow happens... gross...

(define_insn "modsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
        (mod:SI (match_operand:SI 1 "arith_operand" "dI")
                (match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "remi	%2,%1,%0"
  [(set_attr "type" "div")])

(define_insn "umodsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
        (umod:SI (match_operand:SI 1 "arith_operand" "dI")
		 (match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "remo	%2,%1,%0"
  [(set_attr "type" "div")])

;; And instructions (with complement also).

(define_insn "andsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (match_operand:SI 1 "register_operand" "%d")
		(match_operand:SI 2 "logic_operand" "dIM")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
    return \"andnot	%C2,%1,%0\";
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"and	%2,%1,%0\";
  return \"and	%1,%2,%0\";
}")

 (define_insn "*and2clrbit_insn"
   [(set (match_operand:SI 0 "register_operand" "=d")
 	(and:SI (match_operand:SI 1 "arith_operand" "dI")
 		(match_operand:SI 2 "cmplpower2_operand" "n")))]
   ""
   "*
 {
   operands[2] = GEN_INT (i960_bitpos (~INTVAL (operands[2])));
   return \"clrbit	%2,%1,%0\";
 }")

(define_insn "*andnot_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (not:SI (match_operand:SI 1 "register_operand" "d"))
		(match_operand:SI 2 "logic_operand" "dIM")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
    return \"nor	%C2,%1,%0\";
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"notand	%2,%1,%0\";
  return \"andnot	%1,%2,%0\";
}")


(define_insn "iorsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ior:SI (match_operand:SI 1 "register_operand" "%d")
		(match_operand:SI 2 "logic_operand" "dIM")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
    return \"ornot	%C2,%1,%0\";
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"or	%2,%1,%0\";
  return \"or	%1,%2,%0\";
}")

(define_insn "*ior2setbit_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ior:SI (match_operand:SI 1 "register_operand" "d")
		(match_operand:SI 2 "power2_operand" "n")))]
  ""
  "*
{
  operands[2] = GEN_INT (i960_bitpos (INTVAL (operands[2])));
  return \"setbit	%2,%1,%0\";
}")

(define_insn "*ornot_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ior:SI (not:SI (match_operand:SI 1 "register_operand" "d"))
		(match_operand:SI 2 "logic_operand" "dIM")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
    return \"nand	%C2,%1,%0\";
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"notor	%2,%1,%0\";
  return \"ornot	%1,%2,%0\";
}")


(define_insn "xorsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(xor:SI (match_operand:SI 1 "register_operand" "%d")
		(match_operand:SI 2 "logic_operand" "dIM")))]
  ""
  "*
{
  // add support for negative values
  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
    return \"xnor	%C2,%1,%0\";
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"xor	%2,%1,%0\";
  return \"xor	%1,%2,%0\";
}")

(define_insn "*xor2notbit_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(xor:SI (match_operand:SI 1 "arith_operand" "dI")
		(match_operand:SI 2 "power2_operand" "n")))]
  ""
  "*
{
  operands[2] = GEN_INT (i960_bitpos (INTVAL (operands[2])));
  return \"notbit	%2,%1,%0\";
}")

(define_insn "*xnorsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(not:SI (xor:SI (match_operand:SI 1 "register_operand" "%d")
			(match_operand:SI 2 "register_operand" "d"))))]
  ""
  "*
{
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"xnor	%2,%1,%0\";
  return \"xnor	%1,%2,%0\";
}")

(define_insn "*norsi3"
 [(parallel [(use (and:SI (not:SI (match_operand:SI 1 "register_operand" "%d"))
                          (not:SI (match_operand:SI 2 "register_operand" "d"))))
  (set (match_operand:SI 0 "register_operand" "=d")
   (and:SI (not:SI (match_dup 1))
           (not:SI (match_dup 2))))])]
  ""
  "*
{
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"nor	%2,%1,%0\";
  return \"nor	%1,%2,%0\";
}")


;; according to the docs this is the new correct form for nand
;; there needed to be a parallel match sequence for proper matching according
;; to the output logs from the compiler itself
(define_insn "*nandsi3"
 [(parallel [ (use (ior:SI (not:SI (match_operand:SI 1 "register_operand" "%d"))
                          (not:SI (match_operand:SI 2 "register_operand" "d"))))
  (set (match_operand:SI 0 "register_operand" "=d")
      (ior:SI (not:SI (match_dup 1))
              (not:SI (match_dup 2))))])]
  ""
  "*
{
  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"nand	%2,%1,%0\";
  return \"nand	%1,%2,%0\";
}")

(define_insn "*ior2setbit_insn1"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ior:SI (ashift:SI (const_int 1)
			   (match_operand:SI 1 "register_operand" "d"))
		(match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "setbit	%1,%2,%0")

;; (not (ashift 1 reg)) canonicalizes to (rotate -2 reg)
(define_insn "*and_rotate2clrbit_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (rotate:SI (const_int -2)
			   (match_operand:SI 1 "register_operand" "d"))
		(match_operand:SI 2 "register_operand" "d")))]
  ""
  "clrbit	%1,%2,%0")

;; The above pattern canonicalizes to this when both the input and output
;; are the same pseudo-register.
(define_insn "*zeroextract2clrbit_insn1"
  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+d")
			 (const_int 1)
			 (match_operand:SI 1 "register_operand" "d"))
	(const_int 0))]
  ""
  "clrbit	%1,%0,%0")

(define_insn "*xorashift2notbit_insn"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(xor:SI (ashift:SI (const_int 1)
			   (match_operand:SI 1 "register_operand" "d"))
		(match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "notbit	%1,%2,%0")
;; negate operand 1 and store the result in operand 0
(define_insn "negsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(neg:SI (match_operand:SI 1 "arith_operand" "dI")))]
  ""
  "subo	%1,0,%0"
  [(set_attr "length" "1")])
;; store the bitwise-complement of operand 1 into operand 0
(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(not:SI (match_operand:SI 1 "arith_operand" "dI")))]
  ""
  "not	%1,%0"
  [(set_attr "length" "1")])

;; Floating point arithmetic instructions.

(define_insn "adddf3"
  [(set (match_operand:DF 0 "register_operand" "=d*f")
	(plus:DF (match_operand:DF 1 "fp_arith_operand" "%rGH")
		 (match_operand:DF 2 "fp_arith_operand" "rGH")))]
  "TARGET_NUMERICS"
  "addrl	%1,%2,%0"
  [(set_attr "type" "fpadd")])

(define_insn "addsf3"
  [(set (match_operand:SF 0 "register_operand" "=d*f")
	(plus:SF (match_operand:SF 1 "fp_arith_operand" "%rGH")
		 (match_operand:SF 2 "fp_arith_operand" "rGH")))]
  "TARGET_NUMERICS"
  "addr	%1,%2,%0"
  [(set_attr "type" "fpadd")])


(define_insn "subdf3"
  [(set (match_operand:DF 0 "register_operand" "=d*f")
	(minus:DF (match_operand:DF 1 "fp_arith_operand" "rGH")
		  (match_operand:DF 2 "fp_arith_operand" "rGH")))]
  "TARGET_NUMERICS"
  "subrl	%2,%1,%0"
  [(set_attr "type" "fpadd")])

(define_insn "subsf3"
  [(set (match_operand:SF 0 "register_operand" "=d*f")
	(minus:SF (match_operand:SF 1 "fp_arith_operand" "rGH")
		  (match_operand:SF 2 "fp_arith_operand" "rGH")))]
  "TARGET_NUMERICS"
  "subr	%2,%1,%0"
  [(set_attr "type" "fpadd")])


(define_insn "muldf3"
  [(set (match_operand:DF 0 "register_operand" "=d*f")
	(mult:DF (match_operand:DF 1 "fp_arith_operand" "%rGH")
		 (match_operand:DF 2 "fp_arith_operand" "rGH")))]
  "TARGET_NUMERICS"
  "mulrl	%1,%2,%0"
  [(set_attr "type" "fpmul")])

(define_insn "mulsf3"
  [(set (match_operand:SF 0 "register_operand" "=d*f")
	(mult:SF (match_operand:SF 1 "fp_arith_operand" "%rGH")
		 (match_operand:SF 2 "fp_arith_operand" "rGH")))]
  "TARGET_NUMERICS"
  "mulr	%1,%2,%0"
  [(set_attr "type" "fpmul")])


(define_insn "divdf3"
  [(set (match_operand:DF 0 "register_operand" "=d*f")
	(div:DF (match_operand:DF 1 "fp_arith_operand" "rGH")
		(match_operand:DF 2 "fp_arith_operand" "rGH")))]
  "TARGET_NUMERICS"
  "divrl	%2,%1,%0"
  [(set_attr "type" "fpdiv")])

(define_insn "divsf3"
  [(set (match_operand:SF 0 "register_operand" "=d*f")
	(div:SF (match_operand:SF 1 "fp_arith_operand" "rGH")
		(match_operand:SF 2 "fp_arith_operand" "rGH")))]
  "TARGET_NUMERICS"
  "divr	%2,%1,%0"
  [(set_attr "type" "fpdiv")])
;; TODO add custom assembly instruction to automatically encode a two
;; instruction version of notbit, clrbit, and setbit if it makes sense. But if
;; the src and dest are the same then just emit the single instruction
(define_insn "negdf2"
  [(set (match_operand:DF 0 "register_operand" "=d,d*f")
	(neg:DF (match_operand:DF 1 "register_operand" "d,r")))]
  ""
  "*
{
  if (which_alternative == 0)
    {
      if (REGNO (operands[0]) == REGNO (operands[1]))
	return \"notbit	31,%D1,%D0\";
      return \"mov	%1,%0\;notbit	31,%D1,%D0\";
    }
  return \"subrl	%1,0f0.0,%0\";
}"
  [(set_attr "type" "fpadd")])

(define_insn "negsf2"
  [(set (match_operand:SF 0 "register_operand" "=d,d*f")
	(neg:SF (match_operand:SF 1 "register_operand" "d,r")))]
  ""
  "@
  notbit	31,%1,%0
  subr	%1,0f0.0,%0"
  [(set_attr "type" "fpadd")])

;;; The abs patterns also work even if the target machine doesn't have
;;; floating point, because in that case dstreg and srcreg will always be
;;; less than 32.

; Store the absolute value of operand 1 into operand 0
(define_insn "absdf2"
  [(set (match_operand:DF 0 "register_operand" "=d*f")
	(abs:DF (match_operand:DF 1 "register_operand" "df")))]
  ""
  "*
{
  int dstreg = REGNO (operands[0]);
  int srcreg = REGNO (operands[1]);

  if (dstreg < 32) {
      // DEST is GPR 
      if (srcreg < 32) {
        // SRC is GPR

        // need to also transfer src to dest first
        // clrbit does not have enough parameters to accept a fourth one
	    if (dstreg != srcreg) {
	      output_asm_insn (\"mov	%1,%0\", operands);
        }
	    return \"clrbit	31,%D1,%D0\";
	  }
      // FPR -> GPR
      return \"movrl	%1,%0\;clrbit	31,%D1,%D0\";
  }
  // DEST is FPR
  if (srcreg >= 32) {
      // SRC is FPR
      return \"cpysre	%1,0f0.0,%0\";
  }
  // GPR -> FPR
  return \"movrl	%1,%0\;cpysre	%0,0f0.0,%0\";
}"
  [(set_attr "type" "multi")])
; Store the absolute value of operand 1 into operand 0
(define_insn "abssf2"
  [(set (match_operand:SF 0 "register_operand" "=d*f")
	(abs:SF (match_operand:SF 1 "register_operand" "df")))]
  ""
  "*
{
  int dstreg = REGNO (operands[0]);
  int srcreg = REGNO (operands[1]);
// GPR -> GPR 
// the i960 manual says you should use clrbit for pure reals
  if (dstreg < 32 && srcreg < 32)
    return \"clrbit	31,%1,%0\";
// FPR -> FPR
  if (dstreg >= 32 && srcreg >= 32)
    return \"cpysre	%1,0f0.0,%0\";
  // FPR -> GPR
  if (dstreg < 32)
    return \"movr	%1,%0\;clrbit	31,%0,%0\";
  // GPR -> FPR
  return \"movr	%1,%0\;cpysre	%0,0f0.0,%0\";
}"
  [(set_attr "type" "multi")])

;; Tetra (16 byte) float support
;; While technically wrong, the FP registers are 80-bits wide but are treated
;; as 96-bit integers (or triples) which must be quad aligned so it really
;; doesn't matter that TF is wrong.

(define_insn "*cmprtf_insn"
  [(set (reg:CC 36)
	(compare:CC (match_operand:TF 0 "register_operand" "f")
		    (match_operand:TF 1 "nonmemory_operand" "fGH")))]
  "TARGET_NUMERICS"
  "cmpr\t%0,%1"
  [(set_attr "type" "fpcc")])

(define_expand "movtf"
  [(set (match_operand:TF 0 "general_operand" "")
	(match_operand:TF 1 "fpmove_src_operand" ""))]
  ""
  
{
  if (i960_emit_move_sequence (operands, TFmode))
    DONE;
})

(define_insn "*tfvalue_select_insn0"
  [(set (match_operand:TF 0 "nonimmediate_operand"  "=r,f,d,d,m")
	    (match_operand:TF 1 "fpmove_src_operand"    "r,GH,F,m,d"))]
  "(register_operand (operands[0], TFmode) || register_operand (operands[1], TFmode))"
  "* {
  switch (which_alternative)
    {
    case 0:
      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1])) {
	    return \"movre	%1,%0\";
	  } else {
	    return \"movt	%1,%0\";
	  }
    case 1:
      return \"movre	%1,%0\";
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 3:
      return \"ldt	%1,%0\";
    case 4:
      return \"stt	%1,%0\";
    default:
      abort();
    }
}"
  [(set_attr "type" "move,move,load,fpload,fpstore")])

(define_insn "extendsftf2"
  [(set (match_operand:TF 0 "register_operand" "=f,d")
	(float_extend:TF
	 (match_operand:SF 1 "register_operand" "d,f")))]
  "TARGET_NUMERICS"
  "@
  movr	%1,%0
  movre	%1,%0"
  [(set_attr "type" "fpmove")])

(define_insn "extenddftf2"
  [(set (match_operand:TF 0 "register_operand" "=f,d")
	(float_extend:TF
	 (match_operand:DF 1 "register_operand" "d,f")))]
  "TARGET_NUMERICS"
  "@
  movrl	%1,%0
  movre	%1,%0"
  [(set_attr "type" "fpmove")])

(define_insn "trunctfdf2"
  [(set (match_operand:DF 0 "register_operand" "=d")
	(float_truncate:DF
	 (match_operand:TF 1 "register_operand" "f")))]
  "TARGET_NUMERICS"
  "movrl	%1,%0"
  [(set_attr "type" "fpmove")])

(define_insn "trunctfsf2"
  [(set (match_operand:SF 0 "register_operand" "=d")
	(float_truncate:SF
	 (match_operand:TF 1 "register_operand" "f")))]
  "TARGET_NUMERICS"
  "movr	%1,%0"
  [(set_attr "type" "fpmove")])

(define_insn "floatsitf2"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(float:TF (match_operand:SI 1 "register_operand" "d")))]
  "TARGET_NUMERICS"
  "cvtir	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "fix_trunctfsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(fix:SI (fix:TF (match_operand:TF 1 "register_operand" "f"))))]
  "TARGET_NUMERICS"
  "cvtzri	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "fixuns_trunctfsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(unsigned_fix:SI (fix:TF (match_operand:TF 1 "register_operand" "f"))))]
  "TARGET_NUMERICS"
  "cvtzri	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "addtf3"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(plus:TF (match_operand:TF 1 "nonmemory_operand" "%fGH")
		 (match_operand:TF 2 "nonmemory_operand" "fGH")))]
  "TARGET_NUMERICS"
  "addr	%1,%2,%0"
  [(set_attr "type" "fpadd")])

(define_insn "subtf3"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(minus:TF (match_operand:TF 1 "nonmemory_operand" "fGH")
		  (match_operand:TF 2 "nonmemory_operand" "fGH")))]
  "TARGET_NUMERICS"
  "subr	%2,%1,%0"
  [(set_attr "type" "fpadd")])

(define_insn "multf3"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(mult:TF (match_operand:TF 1 "nonmemory_operand" "%fGH")
		 (match_operand:TF 2 "nonmemory_operand" "fGH")))]
  "TARGET_NUMERICS"
  "mulr	%1,%2,%0"
  [(set_attr "type" "fpmul")])

(define_insn "divtf3"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(div:TF (match_operand:TF 1 "nonmemory_operand" "fGH")
		(match_operand:TF 2 "nonmemory_operand" "fGH")))]
  "TARGET_NUMERICS"
  "divr	%2,%1,%0"
  [(set_attr "type" "fpdiv")])

(define_insn "negtf2"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(neg:TF (match_operand:TF 1 "register_operand" "f")))]
  "TARGET_NUMERICS"
  "subr	%1,0f0.0,%0"
  [(set_attr "type" "fpadd")])

(define_insn "abstf2"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(abs:TF (match_operand:TF 1 "register_operand" "f")))]
  "(TARGET_NUMERICS)"
  "cpysre	%1,0f0.0,%0"
  [(set_attr "type" "fpmove")])

;; Arithmetic shift instructions.

;; The shli instruction generates an overflow fault if the sign changes.
;; In the case of overflow, it does not give the natural result, it instead
;; gives the last shift value before the overflow.  We can not use this
;; instruction because gcc thinks that arithmetic left shift and logical
;; left shift are identical, and sometimes canonicalizes the logical left
;; shift to an arithmetic left shift.  Therefore we must always use the
;; logical left shift instruction.

(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ashift:SI (match_operand:SI 1 "arith_operand" "dI")
		   (match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "shlo	%2,%1,%0"
  [(set_attr "type" "alu2")])

(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ashiftrt:SI (match_operand:SI 1 "arith_operand" "dI")
		     (match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "shri	%2,%1,%0"
  [(set_attr "type" "alu2")])

(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(lshiftrt:SI (match_operand:SI 1 "arith_operand" "dI")
		   (match_operand:SI 2 "arith_operand" "dI")))]
  ""
  "shro	%2,%1,%0"
  [(set_attr "type" "alu2")])

;; Unconditional and other jump instructions.

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "b	%l0"
  [(set_attr "type" "branch")])

(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "address_operand" "p"))]
  ""
  "bx	%a0"
  [(set_attr "type" "branch")])

(define_insn "tablejump"
  [(set (pc) (match_operand:SI 0 "register_operand" "d"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  "*
{
  if (flag_pic)
    return \"bx	%l1(%0)\";
  else
    return \"bx	(%0)\";
}"
  [(set_attr "type" "branch")])

;;- jump to subroutine

(define_expand "call"
  [(call (match_operand:SI 0 "memory_operand" "m")
	 (match_operand:SI 1 "immediate_operand" "i"))]
  ""
{
  emit_call_insn (gen_call_internal (operands[0], operands[1],
				     virtual_outgoing_args_rtx));
  DONE;
})

;; We need a call saved register allocated for the match_scratch, so we use
;; 'l' because all local registers are call saved.

;; ??? I would prefer to use a match_scratch here, but match_scratch allocated
;; registers can't be used for spills.  In a function with lots of calls,
;; local-alloc may allocate all local registers to a match_scratch, leaving
;; no local registers available for spills.
;; register 19 is r3 and gets clobbered only if this is a tailcall... which is
;; just annoying overall. Supporting tail calls is just absolutely annoying for
;; so many reasons
(define_insn "call_internal"
  [(call (match_operand:SI 0 "memory_operand" "m")
	 (match_operand:SI 1 "immediate_operand" "i"))
   (use (match_operand:SI 2 "address_operand" "p"))
   (clobber (reg:SI 19))]
  ""
  "* return i960_output_call_insn (operands[0], operands[1], operands[2], insn);"
  [(set_attr "type" "call")])

(define_expand "call_value"
  [(set (match_operand 0 "register_operand" "=d")
	(call (match_operand:SI 1 "memory_operand" "m")
	      (match_operand:SI 2 "immediate_operand" "i")))]
  ""
{
  emit_call_insn (gen_call_value_internal (operands[0], operands[1],
					   operands[2],
				           virtual_outgoing_args_rtx));
  DONE;
})

;; We need a call saved register allocated for the match_scratch, so we use
;; 'l' because all local registers are call saved.

(define_insn "call_value_internal"
  [(set (match_operand 0 "register_operand" "=d")
	(call (match_operand:SI 1 "memory_operand" "m")
	      (match_operand:SI 2 "immediate_operand" "i")))
   (use (match_operand:SI 3 "address_operand" "p"))
   (clobber (reg:SI 19))]
  ""
  "* return i960_output_call_insn (operands[1], operands[2], operands[3],
				   insn);"
  [(set_attr "type" "call")])

(define_insn "return"
  [(return)]
  ""
  "* return i960_output_ret_insn (insn);"
  [(set_attr "type" "branch")])

;; A return instruction.  Used only by nonlocal_goto to change the
;; stack pointer, frame pointer, previous frame pointer and the return
;; instruction pointer.
(define_insn "ret"
  [(set (pc) (unspec_volatile [(reg:SI 16)] 3))]
  ""
  "ret"
  [(set_attr "type" "branch")
   (set_attr "length" "1")])
;; Wow, this works but is really unsafe if any kind of switch comes in at all.
;; You have to be _REALLY_ careful. I guess that it makes sense given this is a
;; nonlocal_goto...gross
(define_expand "nonlocal_goto"
  [(match_operand:SI 0 "" "")
   (match_operand:SI 1 "general_operand" "")
   (match_operand:SI 2 "general_operand" "")
   (match_operand:SI 3 "general_operand" "")]
  ""
  "
{
  rtx chain = operands[0];
  rtx handler = operands[1];
  rtx stack = operands[2];

  /* We must restore the stack pointer, frame pointer, previous frame
     pointer and the return instruction pointer.  Since the ret
     instruction does all this for us with one instruction, we arrange
     everything so that ret will do everything we need done.  */

  /* First, we must flush the register windows, so that we can modify
     the saved local registers on the stack directly and because we
     are going to change the previous frame pointer.  */

  emit_insn (gen_flush_register_windows ());

  /* Load the static chain value for the containing fn into fp.  This is needed
     because STACK refers to fp.  */
  emit_move_insn (hard_frame_pointer_rtx, chain);

  /* Now move the adjusted value into the pfp register for the following return
     instruction.  */
  emit_move_insn (gen_rtx_REG( SImode, 16),
		  plus_constant (Pmode, hard_frame_pointer_rtx, -64));

  /* Next, we put the address that we want to transfer to, into the
     saved $rip value in the frame.  Once we ret below, that value
     will be loaded into the pc (IP).  */

  emit_move_insn (gen_rtx_MEM( SImode,
			   plus_constant (Pmode, hard_frame_pointer_rtx, -56)),
		  handler);

  /* Next, we put stack into the saved $sp value in the frame.  */
  emit_move_insn (gen_rtx_MEM( SImode,
			   plus_constant (Pmode, hard_frame_pointer_rtx, -60)),
		  stack);

  /* And finally, we can now just ret to get all the values saved
     above into all the right registers, and also, all the local
     register that were in use in the function, are restored from
     their saved values (from the call instruction) on the stack
     because we are very careful to ret from the exact save area in
     use during the original call.  */

  emit_jump_insn (gen_ret ());
  emit_barrier ();
  DONE;
}")

;; Special insn to flush register windows.
(define_insn "flush_register_windows"
  [(unspec_volatile [(const_int 0)] 1)]
  ""
  "flushreg"
  [(set_attr "type" "misc")
   (set_attr "length" "1")])

(define_insn "nop"
  [(const_int 0)]
  ""
  "")
;; deactivate peephole optimizations for now
(include "peepholes.md")
;; extra floating point direct operations
;; store the square root of operand 1 into operand 0. Both operands have SF,
;; which is a scalar or vector floating-point mode
(define_insn "sqrtsf2"
    [(set (match_operand:SF 0 "register_operand" "=d*f")
          (sqrt:SF (match_operand:SF 1 "fp_arith_operand" "rGH")))]
    "TARGET_NUMERICS"
    "sqrtr %1,%0")
;; DF version
(define_insn "sqrtdf2"
    [(set (match_operand:DF 0 "register_operand" "=d*f")
          (sqrt:DF (match_operand:DF 1 "fp_arith_operand" "rGH")))]
    "TARGET_NUMERICS"
    "sqrtrl %1,%0")

(define_insn "sqrttf2"
    [(set (match_operand:TF 0 "register_operand" "=f")
          (sqrt:TF (match_operand:TF 1 "fp_arith_operand" "fGH")))]
    "TARGET_NUMERICS"
    "sqrtr %1,%0")
;; TODO implement direct sin, cos, and tan instruction mappings
;; TODO reimplement the test operations since it makes for more compact code
;; clzsi2 (count leading zeros)
;;  scanbit src, dest // find the most significant 1 bit
;;  subo 31, dest, dest2 // subtract 31 from it to get the index
;; extzvsi ... Extract bit field and zero extend 
;;  extract
;; insvsi ...
;;  modify
;; extv ... Extract bit field but from register or memory operand
;; insv
;; TODO support the compare and test operations separately since it is more
;; efficent than using cbranchsi based design. Gcc 3.4.6 actually supports
;; emitting the separate compare and test instructions. I want to emulate this
;; since we support this easily. A good way to know this is basically this:
;; 
;; mov 1, c
;; compare a, b
;; branch? skip
;; mov 0, c
;; skip:
;;
;; condition code is a special register which translate to:
;;
;; compare a, b
;; test? c
;;
;; 

;; the compaction of load and store instructions to save operations needs to
;; happen next I am seeing

;; instructions that are not used by the compiler but could come in handy some day
;;
;; This is not all of the unused instructions, just stuff that could be useful
;;
;; addc
;; alterbit
;; atadd
;; atmod
;; standalone branch instructions?? (questionable)
;; chkbit
;; cmpdeci
;; cmpdeco
;; cmpinci
;; cmpinco
;; cmpor (numerics)
;; cmporl (numerics)
;; cmpstr (protected)
;; concmpi (useful for generating twixt sequences)
;; concmpo (useful for generating twixt sequences)
;; ediv (long ordinal in src2 only but emits remainder and quotient in two registers!)
;; extract
;; fill (protected)
;; modac (if we need to extract the condition code explicitly)
;; modi (not C standard compliant)
;; modify
;; movqstr (protected)
;; movstr (protected)
;; rotate
;; scanbit (search for the most significant set bit and also modifies cc) 
;; scanbyte (byte-by-byte comparison of src1 and src2 and sets cc to true if
;;           any two corresponding bytes are equal)
;; spanbit (search for the most significant clear bit and also modifies cc) 


;; I am thinking that we can use scanbit, scanbyte, and spanbit to support
;; various optimizations. 
;;
;; For example, 
;;    we can implement count leading zeros using spanbit
;;    we can implement count leading ones using scanbit
;;
;; We can use scanbyte to quickly test during a string compare that is
;; optimized to do 32-bit checks. It allows us to blindly load 32-bit values
;; and check to see if we should even check byte by byte. It really is meant
;; for high speed compare operations since we can load packed data without
;; worry. This would be more of a fail test than anything else.

;; Mysteries to diagnose:
;; 1) why is g14 being used in place of fp when va_args are in use? This is _WRONG_
;; 1a) It has nothing to do with setting up for incoming varargs!
;; 1b) It also has nothing to do with va_start
;; 1c) There is some sort of dumb equivalence being stated somewhere

;; I figured out how to implement floatdidf2 earlier today but ran into issues
;; with match problems. Github Copilot helped me realize I need to use a
;; match_scratch operand in the define_insn for the intermediary.
;;
;; According to the intel manual, it is a two instruction sequence to do di to
;; df conversion. You use cvtilr and then a movl to the destination
;; todo What about just the cvtilr due to using the floating point register?
;; todo what about movrl 0.0f,%0
;; todo what about movrl 1.0f,%0
;; (define_insn "floatdidf2"
;;  [(set (match_operand:DF 0 "register_operand" "=d")
;;      (float:DF (match_operand:DI 1 "register_operand" "d")))
;;  (use (match_scratch:DF 2 "=f"))]
;;  "TARGET_NUMERICS"
;;  "cvtilr\t%1,%2\n\tmovrl\t%2,%0"
;;   [(set_attr "type" "fpcvt")])

(define_insn "floatdidf2"
 [(set (match_operand:DF 0 "register_operand" "=f")
     (float:DF (match_operand:DI 1 "register_operand" "d")))]
 "TARGET_NUMERICS"
 "cvtilr\t%1,%0"
  [(set_attr "type" "fpcvt")])

;; Now we also want to support disf which is a single instruction

(define_insn "floatdisf2"
 [(set (match_operand:SF 0 "register_operand" "=d*f")
     (float:SF (match_operand:DI 1 "register_operand" "d")))]
 "TARGET_NUMERICS"
 "cvtilr\t%1,%0"
  [(set_attr "type" "fpcvt")])


;; Instructions that are still not generating properly despite having targets
;; 1) nand
;; 2) nor

;; Instructions that are being generated properly. Confirmed by testing:
;; 1) xnor
;; 2) andnot (notand -> andnot)
;; 3) ornot (notor -> ornot)
;;
