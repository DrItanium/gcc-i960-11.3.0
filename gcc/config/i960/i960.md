;;- Machine description for Intel 80960 chip for GNU C compiler
;;   Copyright (C) 1992, 1995, 1998, 2001 Free Software Foundation, Inc.
;;   Contributed by Steven McGeady, Intel Corp.
;;   Additional work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson
;;   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.
;;   Updated to gcc 11.3.0 by Joshua Scoggins

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
(include "constraints.md")
(include "predicates.md")

;; There are very few (4) 'f' registers, they can't be loaded/stored from/to
;; memory, and some instructions explicitly require them, so we get better
;; code by discouraging pseudo-registers from being allocated to them.
;; However, we do want to allow all patterns which can store to them to
;; include them in their constraints, so we always use '*f' in a destination
;; constraint except when 'f' is the only alternative.
;; Insn attributes which describe the i960.
;; Modscan is not used, since the compiler never emits any of these insns.
(define_attr "type"
  "move,arith,alu2,mult,div,modscan,load,store,branch,call,address,compare,fpload,fpstore,fpmove,fpcvt,fpcc,fpadd,fpmul,fpdiv,multi,misc"
  (const_string "arith"))
;; Length (in # of insns).
(define_attr "length" ""
  (cond [(eq_attr "type" "load,fpload")
	      (if_then_else (match_operand 1 "i960_symbolic_memory_operand" "")
			    (const_int 2)
			    (const_int 1))
	 (eq_attr "type" "store,fpstore")
	      (if_then_else (match_operand 0 "i960_symbolic_memory_operand" "")
			    (const_int 2)
			    (const_int 1))
	 (eq_attr "type" "address")
	      (const_int 2)]
	(const_int 1)))
(define_asm_attributes
  [(set_attr "length" "1")
   (set_attr "type" "multi")])
; normal register move
(define_insn "nop"
 [(const_int 0)]
 ""
 "")

(define_insn "addsi3"
 [(set (match_operand:SI 0 "register_operand" "=d")
     (plus:SI
      (match_operand:SI 1 "signed_arith_operand" "%dI")
      (match_operand:SI 2 "signed_arith_operand" "dI")))]
 ""
 "addo\t%1,%2,%0"
 [(set_attr "type" "mult")])

(define_insn "mulsi3"
 [(set (match_operand:SI 0 "register_operand" "=d")
       (mult:SI (match_operand:SI 1 "signed_arith_operand" "%dI")
                (match_operand:SI 2 "signed_arith_operand" "dI")))]
 ""
 "mulo\t%1,%2,%0")

(define_insn "umulsidi3"
 [(set (match_operand:DI 0 "register_operand" "=d") 
     (mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "d"))
      (zero_extend:DI (match_operand:SI 2 "register_operand" "d))))]
 ""
 "emul\t%1,%2,%0"
 [(set_attr "type" "mult")])

(define_insn ""
 [(set (match_operand:DI 0 "register_operand" "=d") 
     (mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "d"))
      (match_operand:SI 2 "literal" "I")))]
 ""
 "emul\t%1,%2,%0"
 [(set_attr "type" "mult")])
; in i960 land, it is dest = src2/src1 so we flip arguments
(define_insn "divsi3"
 [(set (match_operand:SI 0 "register_operand" "=d")
       (div:SI (match_operand:SI 1 "signed_arith_operand" "%dI")
                (match_operand:SI 2 "signed_arith_operand" "dI")))]
 ""
 "divi\t%2,%1,%0"
 [(set_attr "type" "div")])

(define_insn "udivsi3"
 [(set (match_operand:SI 0 "register_operand" "=d")
       (udiv:SI (match_operand:SI 1 "signed_arith_operand" "%dI")
                (match_operand:SI 2 "signed_arith_operand" "dI")))]
 ""
 "divo\t%2,%1,%0"
 [(set_attr "type" "div")])

(define_insn "subsi3"
 [(set (match_operand:SI 0 "register_operand" "=d")
     (minus:SI (match_operand:SI 1 "arith_operand" "dI")
      (match_operand:SI 2 "arith_operand" "dI")))]
 ""
 "subo\t%2,%1,%0")
